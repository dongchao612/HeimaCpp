C++面向对象的三大特性为：**封装、继承、多态**



C++认为 **万事万物都皆为对象** ，对象上有其属性和行为



**例如：**

​	人可以作为对象，属性有姓名、年龄、身高、体重...，行为有走、跑、跳、吃饭、唱歌...

​	车也可以作为对象，属性有轮胎、方向盘、车灯...，行为有载人、放音乐、放空调...

​	具有相同性质的**对象**，我们可以抽象称为**类**，人属于人类，车属于车类


### 4.1 封装

#### 4.1.1  封装的意义

封装是C++面向对象三大特性之一

封装的意义：

- 将属性和行为作为一个整体，表现生活中的事物
- 将属性和行为加以权限控制



**封装意义一：**

​	在设计类的时候，属性和行为写在一起，表现事物

**语法：** `class 类名{   访问权限： 属性  / 行为  };`



**示例1：** 设计一个圆类，求圆的周长

**示例1代码：**

```C++
#include <iostream>

using namespace std;

// 圆周率
const double PI = 3.14;

// 封装一个圆类，求圆的周长
// class代表设计一个类，后面跟着的是类名

class Circle
{
   public:	// 访问权限  公共的权限
	// 行为
	// 获取到圆的周长
	double calculateZC()
	{
		// 2 * pi  * r
		// 获取圆的周长
		return 2 * PI * this->m_R;
	}

	// 属性
	int m_R;  // 半径
};

int main(int argc, char const *argv[])
{
	// 通过圆类，创建圆的对象
	// c1就是一个具体的圆
	Circle c1;
	c1.m_R = 10;  // 给圆对象的半径 进行赋值操作

	// 2 * pi * 10 = = 62.8
	cout << "圆的周长为： " << c1.calculateZC() << endl;

	return 0;
}
```





**示例2：** 设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号

**示例2代码：**

```C++
#include <iostream>
#include <string>

using namespace std;

//学生类
class Student
{
   public:
	void setName(string name) { this->m_Name = name; }
	void setID(int id) { this->m_Id = id; }

	void showStudent() { cout << "name:" << this->m_Name << " ID:" << this->m_Id << endl; }

   public:
	string m_Name;
	int m_Id;
};

int main(int argc, char const *argv[])
{
	Student stu_zs;
	stu_zs.setName("张三");
	stu_zs.setID(10001);

	stu_zs.showStudent();

	Student stu_ls;
	stu_ls.setName("李四");
	stu_ls.setID(10002);

	stu_ls.showStudent();

	return 0;
}
```









**封装意义二：**

类在设计时，可以把属性和行为放在不同的权限下，加以控制

访问权限有三种：

1. public        公共权限  
2. protected 保护权限
3. private      私有权限






**示例代码：**

```C++
#include <iostream>
#include <string>

using namespace std;

// 三种权限
//  public     类内可以访问  类外可以访问
// 保护权限  protected  类内可以访问  类外不可以访问
// 私有权限  private    类内可以访问  类外不可以访问

class Person
{
	//姓名  公共权限
   public:
	string m_Name;

	//汽车  保护权限
   protected:
	string m_Car;

	//银行卡密码  私有权限
   private:
	int m_Password;

   public:
	void func()
	{
		this->m_Name = "张三";
		this->m_Car = "拖拉机";
		this->m_Password = 123456;
	}
};

int main(int argc, char const *argv[])
{
	Person p;
	p.m_Name = "李四";
	// p.m_Car = "奔驰";  //保护权限类外访问不到
	// p.m_Password = 123; //私有权限类外访问不到

	return 0;
}
```







#### 4.1.2 struct和class区别



在C++中 struct和class唯一的**区别**就在于 **默认的访问权限不同**

区别：

- struct 默认权限为公共
- class   默认权限为私有



```C++
#include <iostream>
#include <string>

using namespace std;

class C1
{
	int m_A;  //默认是私有权限
};

struct C2 {
	int m_A;  //默认是公共权限
};

int main(int argc, char const *argv[])
{
	// 在C++中 struct和class唯一的区别就在于默认的访问权限不同
	// - struct 默认权限为公共
	// - class   默认权限为私有

	C1 c1;
	// c1.m_A = 10;  //错误，访问权限是私有

	C2 c2;
	c2.m_A = 10;  //正确，访问权限是公共

	return 0;
}

```













#### 4.1.3 成员属性设置为私有



**优点1：** 将所有成员属性设置为私有，可以自己控制读写权限

**优点2：** 对于写权限，我们可以检测数据的有效性



**示例：**

```C++
#include <iostream>
#include <string>

using namespace std;

class Person
{
   public:
	//姓名设置可读可写
	void setName(string name) { this->m_Name = name; }
	string getName() { return this->m_Name; }

	//获取年龄
	int getAge() { return this->m_Age; }
#if 1
	//设置年龄
	void setAge(int age)
	{
		if (age < 0 || age > 150) {
			cout << "年龄输出有误，请重新输入!" << endl;
			return;
		}
		this->m_Age = age;
	}
#endif

	//情人设置为只写
	void setLover(string lover) { this->m_Lover = lover; }

   private:
	string m_Name;	//可读可写  姓名

	int m_Age = 18;	 //只读  年龄

	string m_Lover;	 //只写  情人
};

int main(int argc, char const *argv[])
{
	// 优点1：将所有成员属性设置为私有，可以自己控制读写权限
	// 优点2：对于写权限，我们可以检测数据的有效性

	Person p;

	// 姓名设置
	// p.m_Name="张三";
	p.setName("张三");
	cout << "姓名： " << p.getName() << endl;

	//年龄设置
	p.setAge(-50);
	cout << "年龄： " << p.getAge() << endl;

	//情人设置
	p.setLover("小丽");
	// cout << "情人： " << p.m_Lover << endl;  //只写属性，不可以读取
	return 0;
}

```









**练习案例1：设计立方体类**

- 设计立方体类(Cube)

	- 求出立方体的面积和体积

	- 分别用全局函数和成员函数判断两个立方体是否相等。

**示例：**

```c++
#include <iostream>
#include <string>

using namespace std;

/*
设计立方体类(Cube)
	1、求出立方体的面积和体积。
	2、分别用全局函数和成员函数判断两个立方体是否相等。
*/

class Cube
{
   private:
	int m_L;  // 长
	int m_W;  //宽
	int m_H;  //高

   public:
	void setL(int L) { this->m_L = L; }
	int getL() { return this->m_L; }

	void setW(int W) { this->m_W = W; }
	int getW() { return this->m_W; }

	void setH(int H) { this->m_H = H; }
	int getH() { return this->m_H; }

	// 获取表面积
	int calculateS() { return 2 * (this->m_L * this->m_W + this->m_W * this->m_H + this->m_H * this->m_L); }

	// 获取体积
	int calculateV() { return this->m_L * this->m_W * this->m_H; }

	// 成员函数判断两个立方体是否相等。
	bool isSameByClass(Cube &c)
	{
		cout << __FUNCTION__ << ":" << endl;
		if (this->m_L == c.getL() && this->m_W == c.getW() && this->m_H == c.getH()) {
			return true;
		} else {
			return false;
		}
	}
};

// 全局函数判断两个立方体是否相等。
bool isSame(Cube &c1, Cube &c2)
{
	cout << __FUNCTION__ << ":" << endl;
	if (c1.getL() == c2.getL() && c1.getW() == c2.getW() && c1.getH() == c2.getH()) {
		return true;
	} else {
		return false;
	}
}

int main(int argc, char const *argv[])
{
	Cube c1;

	c1.setL(10);
	c1.setH(10);
	c1.setW(10);

	cout << "c1的面积是：" << c1.calculateS() << endl;	// 600
	cout << "c1的体积是：" << c1.calculateV() << endl;	//  1000

	Cube c2;

	c2.setL(10);
	c2.setH(10);
	c2.setW(10);

	bool ret = isSame(c1, c2);
	if (ret) {
		cout << "c1、c2相等" << endl;
	} else {
		cout << "c1、c2不相等" << endl;
	}

	ret = c1.isSameByClass(c2);
	if (ret) {
		cout << "c1、c2相等" << endl;
	} else {
		cout << "c1、c2不相等" << endl;
	}

	return 0;
}

```



**练习案例2：点和圆的关系**

- 设计一个圆形类（Circle），和一个点类（Point）
	- 计算点和圆的关系。


**示例：**
```c++
// point.h
#ifndef CIRCLE_H
#define CIRCLE_H

#include "point.h"

class Circle
{
   private:
	int m_R;  // 半径

	Point m_Center;	 // 在类中可以让定义另一个类作为类中的成员

   public:
	void setR(int R) ;
	int getR() ;

	void setCenter(Point center);
	Point getCenter() ;
};

```c++
// point.cpp
#include "point.h"

void Point::setX(int x) { this->m_X = x; }
int Point::getX() { return this->m_X; }

void Point::setY(int y) { this->m_Y = y; }
int Point::getY() { return this->m_Y; }
```

```c++
// circle.h
#ifndef CIRCLE_H
#define CIRCLE_H

#include "point.h"

class Circle
{
   private:
	int m_R;  // 半径

	Point m_Center;	 // 在类中可以让定义另一个类作为类中的成员

   public:
	void setR(int R) ;
	int getR() ;

	void setCenter(Point center);
	Point getCenter() ;
};


#endif   //  CIRCLE_H

```

```c++
// circle.cpp
#include "circle.h"

void Circle::setR(int R) { this->m_R = R; }
int Circle::getR() { return this->m_R; }

void Circle::setCenter(Point center) { this->m_Center = center; }
Point Circle::getCenter() { return this->m_Center; }

#endif   //  CIRCLE_H
``` 



### 4.2 对象的初始化和清理



- 生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全
- C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。





#### 4.2.1 构造函数和析构函数

对象的**初始化和清理**也是两个非常重要的安全问题

​	一个对象或者变量没有初始状态，对其使用后果是未知

​	同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题



c++利用了**构造函数**和**析构函数**解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。

对象的初始化和清理工作是编译器强制要我们做的事情，因此如果**我们不提供构造和析构，编译器会提供**

**编译器提供的构造函数和析构函数是空实现。**



* 构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
* 析构函数：主要作用在于对象**销毁前**系统自动调用，执行一些清理工作。





**构造函数语法：**`类名(){}`

1. 构造函数，没有返回值也不写void
2. 函数名称与类名相同
3. 构造函数可以有参数，因此可以发生重载
4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次





**析构函数语法：** `~类名(){}`

1. 析构函数，没有返回值也不写void
2. 函数名称与类名相同,在名称前加上符号  ~
3. 析构函数不可以有参数，因此不可以发生重载
4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次




**示例代码：**
```C++
#include <iostream>

using namespace std;

class Person
{
   public:
	/*
	 构造函数
		 1. 构造函数，没有返回值也不写void
		 2. 函数名称与类名相同
		 3. 构造函数可以有参数，因此可以发生重载
		 4. 程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次
	*/
	Person() { cout << "Person的构造函数调用" << endl; }

	/*
	析构函数
		1. 析构函数，没有返回值也不写void
		2. 函数名称与类名相同,在名称前加上符号  ~
		3. 析构函数不可以有参数，因此不可以发生重载
		4. 程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次
	*/
	~Person() { cout << "Person的析构函数调用" << endl; }
};

int main(int argc, char const *argv[])
{
	Person p;

	return 0;
}

```











#### 4.2.2 构造函数的分类及调用

两种分类方式：

- 按参数分为： 有参构造和无参构造
- 按类型分为： 普通构造和拷贝构造

三种调用方式：

​	1. 括号法

> 注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明

​	2. 显示法

​	3. 隐式转换法

> 注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明



**示例代码：**

```C++
#include <iostream>

using namespace std;

// 1、构造函数分类
//  按照参数分类分为 有参和无参构造   无参又称为默认构造函数
//  按照类型分类分为 普通构造和拷贝构造

class Person
{
   public:
	//构造函数
	Person() { cout << "Person的无参构造函数调用" << endl; }

	// 有参构造函数
	Person(int age)
	{
		this->m_Age = age;
		cout << "Person的有参构造函数调用" << endl;
	}

	// 拷贝构造函数
	Person(const Person& p)
	{
		this->m_Age = p.m_Age;
		cout << "Person的拷贝构造函数调用" << endl;
	}

	// 析构函数
	~Person() { cout << "Person的析构函数调用" << endl; }
	int m_Age;
};

void test01()
{
#if 0
	// 1  括号法，常用
	Person p1;		// 无参构造函数
	Person p2(10);	// 有参的构造函数
	Person p3(p2);	// 拷贝构造函数

	// cout << "p2的年龄：" << p2.m_Age << endl;
	// cout << "p3的年龄：" << p3.m_Age << endl;

    // 注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明
#endif

#if 0
	// 2 显式法
	Person p1;				 // 无参构造
	Person p2 = Person(10);	 // 有参构造
	Person p3 = Person(p2);	 // 拷贝构造
							 // Person(10);  单独写就是匿名对象  当前行结束之后，马上析构

	// 注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明
	// Person p5(p4);
#endif
	// 3 隐式转换法
	Person p1 = 10;	 // Person p1 = Person(10);
	Person p2 = p1;	 // Person p2 = Person(p1);
}

int main(int argc, char const* argv[])
{
	test01();
	return 0;
}

```









#### 4.2.3 拷贝构造函数调用时机



C++中拷贝构造函数调用时机通常有三种情况

* 使用一个已经创建完毕的对象来初始化一个新对象
* 值传递的方式给函数参数传值
* 以值方式返回局部对象



**示例代码：**

```C++
#include <iostream>

using namespace std;

class Person
{
   public:
	Person()
	{
		cout << "Person的无参构造函数!" << endl;
		m_Age = 0;
	}

	Person(int age)
	{
		cout << "Person的有参构造函数!" << endl;
		m_Age = age;
	}

	Person(const Person& p)
	{
		this->m_Age = p.m_Age;
		cout << "Person的拷贝构造函数!" << endl;
	}

	~Person() { cout << "Person的析构函数!" << endl; }

   public:
	int m_Age;
};

// 1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
	Person p1(100);	 // p对象已经创建完毕
	Person p2(p1);	 //调用拷贝构造函数
}

// 2. 值传递的方式给函数参数传值
void doWork(Person p1) {}
void test02()
{
	Person p;  //无参构造函数
	doWork(p);
}

// 3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout << (int*)&p1 << endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout << (int*)&p << endl;
}

int main(int argc, char const* argv[])
{
	// test01();
	// test02();
	test03();
	return 0;
}

```









#### 4.2.4 构造函数调用规则

默认情况下，c++编译器至少给一个类添加3个函数

1．默认构造函数(无参，函数体为空)

2．默认析构函数(无参，函数体为空)

3．默认拷贝构造函数，对属性进行值拷贝



构造函数调用规则如下：

* 如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造


* 如果用户定义拷贝构造函数，c++不会再提供其他构造函数



**示例代码：**

```C++
#include <iostream>

using namespace std;

class Person
{
   public:
#if 0
	Person()
	{
		cout << "Person的无参构造函数!" << endl;
		this->m_Age = 0;
	}
#endif

#if 0
	Person(int age)
	{
		cout << "Person的有参构造函数!" << endl;
		this->m_Age = age;
	}
#endif

#if 1
	Person(const Person& p)
	{
		this->m_Age = p.m_Age;
		cout << "Person的拷贝构造函数!" << endl;
	}
#endif
	~Person() { cout << "Person的析构函数!" << endl; }

   public:
	int m_Age;
};

#if 0
void test01()
{
	Person p1;
	p1.m_Age = 18;
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout << "p2的年龄为： " << p2.m_Age << endl;
}
#endif

void test02()
{
#if 0
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	// Person p1;		//此时如果用户自己没有提供默认构造，会出错
	Person p1(20);	//用户提供的有参
	Person p2(p1);	//此时如果用户没有提供拷贝构造，编译器会提供

    cout << "p2的年龄为： " << p2.m_Age << endl;
#endif

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	// Person p1;		//此时如果用户自己没有提供默认构造，会出错
	// Person p5(10);	//此时如果用户自己没有提供有参，会出错
	// Person p6(p5);	//用户自己提供拷贝构造
}

int main(int argc, char const* argv[])
{
	// test01();
	test02();
	return 0;
}

```









#### 4.2.5 深拷贝与浅拷贝



深浅拷贝是面试经典问题，也是常见的一个坑

- 浅拷贝：简单的赋值拷贝操作
- 深拷贝：在堆区重新申请空间，进行拷贝操作



**示例代码：**

```C++
#include <iostream>

using namespace std;

class Person
{
   public:
	//无参（默认）构造函数
	Person() { cout << "Person的无参构造函数!" << endl; }

	//有参构造函数
	Person(int age, int height)
	{
		cout << "Person的有参构造函数!" << endl;

		this->m_Age = age;
		this->m_Height = new int(height);
	}
#if 1
	//拷贝构造函数
	Person(const Person& p)
	{
		cout << "Person的拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		this->m_Age = p.m_Age;
		// this->m_Height=p.m_Height;  //编译实现的代码
		this->m_Height = new int(*p.m_Height);
	}
#endif
	//析构函数
	~Person()
	{
		cout << "析构函数!" << endl;
		if (m_Height != NULL) {
			delete m_Height;
		}
		m_Height = NULL;
	}

   public:
	int m_Age;
	int* m_Height;
};

void test01()
{
	Person p1(18, 180);
	cout << "p1的年龄： " << p1.m_Age << " 身高： " << *p1.m_Height << endl;

	Person p2(p1);
	cout << "p2的年龄： " << p2.m_Age << " 身高： " << *p2.m_Height << endl;
}

int main(int argc, char const* argv[])
{
	test01();
	return 0;
}

```

> 总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题









#### 4.2.6 初始化列表



**作用：**

C++提供了初始化列表语法，用来初始化属性



**语法：**`构造函数()：属性1(值1),属性2（值2）... {}`



**示例代码：**

```C++
#include <iostream>

using namespace std;

class Person
{
   public:
#if 0
	//传统方式初始化
	Person(int a, int b, int c)
	{
		m_A = a;
		m_B = b;
		m_C = c;
	}
#endif
	//初始化列表方式初始化
	Person() : m_A(10), m_B(20), m_C(30) {}
	Person(int a, int b, int c) : m_A(a), m_B(b), m_C(c) {}
	void PrintPerson() { cout << "m_A:" << m_A << "\tm_B:" << m_B << "\tm_C:" << m_C << endl; }

   private:
	int m_A;
	int m_B;
	int m_C;
};

int main(int argc, char const *argv[])
{
	// Person p(1, 2, 3);
	// p.PrintPerson();

	// Person p;
	// p.PrintPerson();

	Person p(1, 2, 3);
	p.PrintPerson();

	return 0;
}

```





#### 4.2.7 类对象作为类成员



C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员



例如：

```C++
class A {}
class B
{
    A a；
}
```



B类中有对象A作为成员，A为对象成员



那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？



**示例代码：**

```C++
#include <iostream>
#include <string>

using namespace std;

class Phone
{
   public:
	Phone(string name)
	{
		this->m_PhoneName = name;
		cout << "Phone的构造函数" << endl;
	}

	~Phone() { cout << "Phone的析构函数" << endl; }

	string m_PhoneName;
};

class Person
{
   public:
	//初始化列表可以告诉编译器调用哪一个构造函数
	Person(string name, string pName) : m_Name(name), m_Phone(pName) { cout << "Person的析构函数" << endl; }

	~Person() { cout << "Person的析构函数" << endl; }

	void playGame() { cout << m_Name << " 使用" << m_Phone.m_PhoneName << " 牌手机! " << endl; }

	string m_Name;
	Phone m_Phone;
};

void test01()
{
	//当类中成员是其他类对象时，我们称该成员为 对象成员
	//构造的顺序是 ：先调用对象成员的构造，再调用本类构造
	//析构顺序与构造相反
	Person p("张三", "苹果X");
	p.playGame();
}
int main(int argc, char const *argv[])
{
	test01();
	return 0;
}

```











#### 4.2.8 静态成员

静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员

静态成员分为：



*  静态成员变量
   *  所有对象共享同一份数据
   *  在编译阶段分配内存
   *  类内声明，类外初始化
*  静态成员函数
   *  所有对象共享同一个函数
   *  静态成员函数只能访问静态成员变量







**示例1代码 ：** 静态成员变量

```C++
#include <iostream>

using namespace std;

//静态成员变量特点：
// 1 在编译阶段分配内存
// 2 类内声明，类外初始化
// 3 所有对象共享同一份数据

class Person
{
   public:
	static int m_A;	 //静态成员变量

   private:
	static int m_B;	 //静态成员变量也是有访问权限的
};

int Person::m_A = 100;
int Person::m_B = 10;

void test01()
{
	Person p1;
	cout << "p1.m_A = " << p1.m_A << endl;

	Person p2;
	p2.m_A = 200;
	cout << "p2.m_A = " << p2.m_A << endl;
}

void test02()
{
	//静态成员变量两种访问方式
	// 1、通过对象
	Person p1;
	p1.m_A = 100;
	cout << "p1.m_A = " << p1.m_A << endl;

	Person p2;
	p2.m_A = 200;
	cout << "p1.m_A = " << p1.m_A << endl;	//共享同一份数据
	cout << "p2.m_A = " << p2.m_A << endl;

	// 2、通过类名
	cout << "m_A = " << Person::m_A << endl;
	// cout << "m_B = " << Person::m_B << endl; //私有权限访问不到
}
int main(int argc, char const *argv[])
{
	// test01();
	test02();
	return 0;
}

```



**示例2代码：** 静态成员函数

```C++
#include <iostream>

using namespace std;

//静态成员函数特点：
// 1 程序共享一个函数
// 2 静态成员函数只能访问静态成员变量

class Person
{
   public:
	static void func()
	{
		cout << "static void func() 调用" << endl;
		m_A = 100;
		// m_B = 100; //错误，不可以访问非静态成员变量
	}

	static int m_A;	 //静态成员变量
	int m_B;		 //
   private:
	//静态成员函数也是有访问权限的
	static void func2() { cout << "static void func2调用" << endl; }
};
int Person::m_A = 10;

void test01()
{
	//静态成员变量两种访问方式

	// 1、通过对象
	Person p1;
	p1.func();

	// 2、通过类名
	Person::func();
	// Person::func2(); //私有权限访问不到
}

int main(int argc, char const *argv[])
{
	test01();
	return 0;
}
```






### 4.3 C++对象模型和this指针



#### 4.3.1 成员变量和成员函数分开存储



在C++中，类内的成员变量和成员函数分开存储

只有非静态成员变量才属于类的对象上



```C++
class Person {
public:
	Person() {
		mA = 0;
	}
	//非静态成员变量占对象空间
	int mA;
	//静态成员变量不占对象空间
	static int mB; 
	//函数也不占对象空间，所有函数共享一个函数实例
	void func() {
		cout << "mA:" << this->mA << endl;
	}
	//静态成员函数也不占对象空间
	static void sfunc() {
	}
};

int main() {

	cout << sizeof(Person) << endl;

	system("pause");

	return 0;
}
```







#### 4.3.2 this指针概念

通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的

每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码

那么问题是：这一块代码是如何区分那个对象调用自己的呢？



c++通过提供特殊的对象指针，this指针，解决上述问题。**this指针指向被调用的成员函数所属的对象**



this指针是隐含每一个非静态成员函数内的一种指针

this指针不需要定义，直接使用即可



this指针的用途：

*  当形参和成员变量同名时，可用this指针来区分
*  在类的非静态成员函数中返回对象本身，可使用return *this

```C++
class Person
{
public:

	Person(int age)
	{
		//1、当形参和成员变量同名时，可用this指针来区分
		this->age = age;
	}

	Person& PersonAddPerson(Person p)
	{
		this->age += p.age;
		//返回对象本身
		return *this;
	}

	int age;
};

void test01()
{
	Person p1(10);
	cout << "p1.age = " << p1.age << endl;

	Person p2(10);
	p2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);
	cout << "p2.age = " << p2.age << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```









#### 4.3.3 空指针访问成员函数



C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针



如果用到this指针，需要加以判断保证代码的健壮性



**示例：**

```C++
//空指针访问成员函数
class Person {
public:

	void ShowClassName() {
		cout << "我是Person类!" << endl;
	}

	void ShowPerson() {
		if (this == NULL) {
			return;
		}
		cout << mAge << endl;
	}

public:
	int mAge;
};

void test01()
{
	Person * p = NULL;
	p->ShowClassName(); //空指针，可以调用成员函数
	p->ShowPerson();  //但是如果成员函数中用到了this指针，就不可以了
}

int main() {

	test01();

	system("pause");

	return 0;
}
```









#### 4.3.4 const修饰成员函数



**常函数：**

* 成员函数后加const后我们称为这个函数为**常函数**
* 常函数内不可以修改成员属性
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改



**常对象：**

* 声明对象前加const称该对象为常对象
* 常对象只能调用常函数







**示例：**

```C++
class Person {
public:
	Person() {
		m_A = 0;
		m_B = 0;
	}

	//this指针的本质是一个指针常量，指针的指向不可修改
	//如果想让指针指向的值也不可以修改，需要声明常函数
	void ShowPerson() const {
		//const Type* const pointer;
		//this = NULL; //不能修改指针的指向 Person* const this;
		//this->mA = 100; //但是this指针指向的对象的数据是可以修改的

		//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量
		this->m_B = 100;
	}

	void MyFunc() const {
		//mA = 10000;
	}

public:
	int m_A;
	mutable int m_B; //可修改 可变的
};


//const修饰对象  常对象
void test01() {

	const Person person; //常量对象  
	cout << person.m_A << endl;
	//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问
	person.m_B = 100; //但是常对象可以修改mutable修饰成员变量

	//常对象访问成员函数
	person.MyFunc(); //常对象不能调用const的函数

}

int main() {

	test01();

	system("pause");

	return 0;
}
```



### 4.4 友元



生活中你的家有客厅(Public)，有你的卧室(Private)

客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去

但是呢，你也可以允许你的好闺蜜好基友进去。



在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术



友元的目的就是让一个函数或者类 访问另一个类中私有成员



友元的关键字为  ==friend==



友元的三种实现

* 全局函数做友元
* 类做友元
* 成员函数做友元





#### 4.4.1 全局函数做友元

```C++
class Building
{
	//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容
	friend void goodGay(Building * building);

public:

	Building()
	{
		this->m_SittingRoom = "客厅";
		this->m_BedRoom = "卧室";
	}


public:
	string m_SittingRoom; //客厅

private:
	string m_BedRoom; //卧室
};


void goodGay(Building * building)
{
	cout << "好基友正在访问： " << building->m_SittingRoom << endl;
	cout << "好基友正在访问： " << building->m_BedRoom << endl;
}


void test01()
{
	Building b;
	goodGay(&b);
}

int main(){

	test01();

	system("pause");
	return 0;
}
```



#### 4.4.2 类做友元



```C++
class Building;
class goodGay
{
public:

	goodGay();
	void visit();

private:
	Building *building;
};


class Building
{
	//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容
	friend class goodGay;

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay gg;
	gg.visit();

}

int main(){

	test01();

	system("pause");
	return 0;
}
```





#### 4.4.3 成员函数做友元



```C++
class Building;
class goodGay
{
public:

	goodGay();
	void visit(); //只让visit函数作为Building的好朋友，可以发访问Building中私有内容
	void visit2(); 

private:
	Building *building;
};


class Building
{
	//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容
	friend void goodGay::visit();

public:
	Building();

public:
	string m_SittingRoom; //客厅
private:
	string m_BedRoom;//卧室
};

Building::Building()
{
	this->m_SittingRoom = "客厅";
	this->m_BedRoom = "卧室";
}

goodGay::goodGay()
{
	building = new Building;
}

void goodGay::visit()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void goodGay::visit2()
{
	cout << "好基友正在访问" << building->m_SittingRoom << endl;
	//cout << "好基友正在访问" << building->m_BedRoom << endl;
}

void test01()
{
	goodGay  gg;
	gg.visit();

}

int main(){
    
	test01();

	system("pause");
	return 0;
}
```
### 4.5 运算符重载



运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型



#### 4.5.1 加号运算符重载



作用：实现两个自定义数据类型相加的运算



```C++
#include <iostream>

using namespace std;

class Person
{
   public:
	Person(){};
	Person(int a, int b)
	{
		this->m_A = a;
		this->m_B = b;
	}
    
	//成员函数实现 + 号运算符重载
	Person operator+(const Person& p) { return Person(this->m_A + p.m_A, this->m_B + p.m_B); }

   public:
	int m_A;
	int m_B;
};

//全局函数实现 + 号运算符重载
Person operator+(const Person& p1, const Person& p2) { return Person(p1.m_A + p2.m_A, p1.m_B + p2.m_B); }

//运算符重载 可以发生函数重载
Person operator+(const Person& p2, int val) { return Person(p2.m_A + val, p2.m_B + val); }

void test01()
{
	Person p1(10, 10);
	Person p2(20, 20);

	// 成员函数方式
	Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)
	cout << "mA:" << p3.m_A << " mB:" << p3.m_B << endl;
}

void test02()
{
	Person p1(10, 10);
	Person p2(20, 20);

	// 全局函数方式
	Person p3 = p2 + p1;  //相当于 p2.operaor+(p1)
	cout << "mA:" << p3.m_A << " mB:" << p3.m_B << endl;
}


void test03()
{
	Person p1(10, 10);

	// 全局函数方式
	Person  p2 = p1 + 20; //相当于 operator+(p1,10)
	cout << "mA:" << p2.m_A << " mB:" << p2.m_B << endl;
}

int main(int argc, char const* argv[])
{
	test01();
	test02();
    test03();

	return 0;
}
```



> 总结1：对于内置的数据类型的表达式的的运算符是不可能改变的

> 总结2：不要滥用运算符重载







#### 4.5.2 左移运算符重载



作用：可以输出自定义数据类型



```C++
class Person {
	friend ostream& operator<<(ostream& out, Person& p);

public:

	Person(int a, int b)
	{
		this->m_A = a;
		this->m_B = b;
	}

	//成员函数 实现不了  p << cout 不是我们想要的效果
	//void operator<<(Person& p){
	//}

private:
	int m_A;
	int m_B;
};

//全局函数实现左移重载
//ostream对象只能有一个
ostream& operator<<(ostream& out, Person& p) {
	out << "a:" << p.m_A << " b:" << p.m_B;
	return out;
}

void test() {

	Person p1(10, 20);

	cout << p1 << "hello world" << endl; //链式编程
}

int main() {

	test();

	system("pause");

	return 0;
}
```



> 总结：重载左移运算符配合友元可以实现输出自定义数据类型













#### 4.5.3 递增运算符重载



作用： 通过重载递增运算符，实现自己的整型数据



```C++
class MyInteger {

	friend ostream& operator<<(ostream& out, MyInteger myint);

public:
	MyInteger() {
		m_Num = 0;
	}
	//前置++
	MyInteger& operator++() {
		//先++
		m_Num++;
		//再返回
		return *this;
	}

	//后置++
	MyInteger operator++(int) {
		//先返回
		MyInteger temp = *this; //记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；
		m_Num++;
		return temp;
	}

private:
	int m_Num;
};


ostream& operator<<(ostream& out, MyInteger myint) {
	out << myint.m_Num;
	return out;
}


//前置++ 先++ 再返回
void test01() {
	MyInteger myInt;
	cout << ++myInt << endl;
	cout << myInt << endl;
}

//后置++ 先返回 再++
void test02() {

	MyInteger myInt;
	cout << myInt++ << endl;
	cout << myInt << endl;
}

int main() {

	test01();
	//test02();

	system("pause");

	return 0;
}
```



> 总结： 前置递增返回引用，后置递增返回值













#### 4.5.4 赋值运算符重载



c++编译器至少给一个类添加4个函数

1. 默认构造函数(无参，函数体为空)
2. 默认析构函数(无参，函数体为空)
3. 默认拷贝构造函数，对属性进行值拷贝
4. 赋值运算符 operator=, 对属性进行值拷贝





如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题





**示例：**

```C++
class Person
{
public:

	Person(int age)
	{
		//将年龄数据开辟到堆区
		m_Age = new int(age);
	}

	//重载赋值运算符 
	Person& operator=(Person &p)
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
		//编译器提供的代码是浅拷贝
		//m_Age = p.m_Age;

		//提供深拷贝 解决浅拷贝的问题
		m_Age = new int(*p.m_Age);

		//返回自身
		return *this;
	}


	~Person()
	{
		if (m_Age != NULL)
		{
			delete m_Age;
			m_Age = NULL;
		}
	}

	//年龄的指针
	int *m_Age;

};


void test01()
{
	Person p1(18);

	Person p2(20);

	Person p3(30);

	p3 = p2 = p1; //赋值操作

	cout << "p1的年龄为：" << *p1.m_Age << endl;

	cout << "p2的年龄为：" << *p2.m_Age << endl;

	cout << "p3的年龄为：" << *p3.m_Age << endl;
}

int main() {

	test01();

	//int a = 10;
	//int b = 20;
	//int c = 30;

	//c = b = a;
	//cout << "a = " << a << endl;
	//cout << "b = " << b << endl;
	//cout << "c = " << c << endl;

	system("pause");

	return 0;
}
```









#### 4.5.5 关系运算符重载



**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作



**示例：**

```C++
class Person
{
public:
	Person(string name, int age)
	{
		this->m_Name = name;
		this->m_Age = age;
	};

	bool operator==(Person & p)
	{
		if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	bool operator!=(Person & p)
	{
		if (this->m_Name == p.m_Name && this->m_Age == p.m_Age)
		{
			return false;
		}
		else
		{
			return true;
		}
	}

	string m_Name;
	int m_Age;
};

void test01()
{
	//int a = 0;
	//int b = 0;

	Person a("孙悟空", 18);
	Person b("孙悟空", 18);

	if (a == b)
	{
		cout << "a和b相等" << endl;
	}
	else
	{
		cout << "a和b不相等" << endl;
	}

	if (a != b)
	{
		cout << "a和b不相等" << endl;
	}
	else
	{
		cout << "a和b相等" << endl;
	}
}


int main() {

	test01();

	system("pause");

	return 0;
}
```





#### 4.5.6 函数调用运算符重载



* 函数调用运算符 ()  也可以重载
* 由于重载后使用的方式非常像函数的调用，因此称为仿函数
* 仿函数没有固定写法，非常灵活



**示例：**

```C++
class MyPrint
{
public:
	void operator()(string text)
	{
		cout << text << endl;
	}

};
void test01()
{
	//重载的（）操作符 也称为仿函数
	MyPrint myFunc;
	myFunc("hello world");
}


class MyAdd
{
public:
	int operator()(int v1, int v2)
	{
		return v1 + v2;
	}
};

void test02()
{
	MyAdd add;
	int ret = add(10, 10);
	cout << "ret = " << ret << endl;

	//匿名对象调用  
	cout << "MyAdd()(100,100) = " << MyAdd()(100, 100) << endl;
}

int main() {

	test01();
	test02();

	system("pause");

	return 0;
}
```




